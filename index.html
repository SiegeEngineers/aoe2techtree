<!DOCTYPE html>
<html lang="en">

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <meta charset="utf-8"/>
    <title>Age of Empires II Tech Tree</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap">
</head>

<body>
<div id="container">
    <div id="wrapper">
        <div id="metainfo">
            <div id="civinfo">
                <div id="civtitle">
                    <select id="civselect" onchange="loadCiv()">
                        <option data-i18n="10285" data-key="Aztecs">Aztecs</option>
                        <option data-i18n="10297" data-key="Berbers">Berbers</option>
                        <option data-i18n="10271" data-key="Britons">Britons</option>
                        <option data-i18n="10302" data-key="Bulgarians">Bulgarians</option>
                        <option data-i18n="10300" data-key="Burmese">Burmese</option>
                        <option data-i18n="10277" data-key="Byzantines">Byzantines</option>
                        <option data-i18n="10283" data-key="Celts">Celts</option>
                        <option data-i18n="10276" data-key="Chinese">Chinese</option>
                        <option data-i18n="10304" data-key="Cumans">Cumans</option>
                        <option data-i18n="10295" data-key="Ethiopians">Ethiopians</option>
                        <option data-i18n="10272" data-key="Franks">Franks</option>
                        <option data-i18n="10273" data-key="Goths">Goths</option>
                        <option data-i18n="10287" data-key="Huns">Huns</option>
                        <option data-i18n="10291" data-key="Incas">Incas</option>
                        <option data-i18n="10290" data-key="Indians">Indians</option>
                        <option data-i18n="10289" data-key="Italians">Italians</option>
                        <option data-i18n="10275" data-key="Japanese">Japanese</option>
                        <option data-i18n="10298" data-key="Khmer">Khmer</option>
                        <option data-i18n="10288" data-key="Koreans">Koreans</option>
                        <option data-i18n="10305" data-key="Lithuanians">Lithuanians</option>
                        <option data-i18n="10292" data-key="Magyars">Magyars</option>
                        <option data-i18n="10299" data-key="Malay">Malay</option>
                        <option data-i18n="10296" data-key="Malians">Malians</option>
                        <option data-i18n="10286" data-key="Mayans">Mayans</option>
                        <option data-i18n="10282" data-key="Mongols">Mongols</option>
                        <option data-i18n="10278" data-key="Persians">Persians</option>
                        <option data-i18n="10294" data-key="Portuguese">Portuguese</option>
                        <option data-i18n="10279" data-key="Saracens">Saracens</option>
                        <option data-i18n="10293" data-key="Slavs">Slavs</option>
                        <option data-i18n="10284" data-key="Spanish">Spanish</option>
                        <option data-i18n="10303" data-key="Tatars">Tatars</option>
                        <option data-i18n="10274" data-key="Teutons">Teutons</option>
                        <option data-i18n="10280" data-key="Turks">Turks</option>
                        <option data-i18n="10301" data-key="Vietnamese">Vietnamese</option>
                        <option data-i18n="10281" data-key="Vikings">Vikings</option>
                    </select>
                    <img id="civlogo" height="81" width="81" data-transparent="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=">
                </div>
                <p id="civtext"></p>
                <div id="loading" class="lds-dual-ring"></div>
            </div>
            <div class="key">
                <b id="key__label"></b>
                <table border="0" cellspacing="10" id="color_key">
                    <colgroup>
                        <col width="23"/>
                        <col width="110"/>
                        <col width="23"/>
                        <col width="110"/>
                    </colgroup>
                </table>
            </div>
            <div class="locales-supported">
                <!-- "Language supported" in the same order as they appear in Microsoft's product page:
                     https://www.microsoft.com/en-us/p/age-of-empires-ii-definitive-edition/9njdd0jgpp2q -->
                [<a href="#" title="English (United States)" data-lang="en">en</a>]
                [<a href="#" title="中文(中国)" data-lang="zh">zh</a>]
                [<a href="#" title="中文(香港特別行政區)" data-lang="tw">tw</a>]
                [<a href="#" title="Français (France)" data-lang="fr">fr</a>]
                [<a href="#" title="Deutsch (Deutschland)" data-lang="de">de</a>]
                [<a href="#" title="हिंदी (भारत)" data-lang="hi">hi</a>]
                [<a href="#" title="Italiano (Italia)" data-lang="it">it</a>]
                [<a href="#" title="日本語 (日本)" data-lang="jp">jp</a>]
                [<a href="#" title="한국어(대한민국)" data-lang="ko">ko</a>]
                [<a href="#" title="Bahasa Melayu (Malaysia)" data-lang="ms">ms</a>]
                [<a href="#" title="Русский (Россия)" data-lang="ru">ru</a>]
                [<a href="#" title="Español (España, Internacional)" data-lang="es">es</a>]
                [<a href="#" title="Español (México)" data-lang="mx">mx</a>]
                [<a href="#" title="Türkçe (Türkiye)" data-lang="tr">tr</a>]
                [<a href="#" title="Tiếng Việt (Việt Nam)" data-lang="vi">vi</a>]
                [<a href="#" title="Português (Brasil)" data-lang="br">br</a>]
            </div>
            <div class="credits">
                <p>
                    Version: Age of Empires II DE Update <a href="https://www.ageofempires.com/news/aoe2de-update-36906/" target="_blank" title="Changelog" rel="nofollow">36906</a>
                </p>
                <p>
                    A project by <a href="https://aoe2.se" rel="author" class="has-text-grey">Siege Engineers</a>. Contribute on <a href="https://github.com/SiegeEngineers/aoe2techtree" target="_blank">GitHub</a>
                </p>
                <p>
                    Made by hszemi, Anda, exterkamp, paulirish<br>
                    with thanks to Jineapple, TriRem, pip, and NkoDragaš<br>
                </p>
                <p>
                    Item Metadata (cost, HP etc.) taken from <a href="https://github.com/HSZemi/aoe2dat" target="_blank">aoe2dat</a>
                </p>
                <p>
                    Age of Empires II &copy; Microsoft Corporation.<br>
                    <b>aoe2techtree</b> was created under Microsoft's "<a href="https://www.xbox.com/en-us/developers/rules" rel="nofollow">Game Content Usage Rules</a>" using assets
                    from Age of Empires II, and it is not endorsed by or affiliated with Microsoft.
                </p>
            </div>
        </div>
        <div id="techtree">
            <div id="helptext">
                <div id="helptext__content"></div>
                <details id="advanced-stats">
                    <summary>Advanced Stats</summary>
                    <div id="helptext__advanced_stats"></div>
                    <div id="helptext__x_ref"><h3>Civilizations</h3></div>
                </details>
              </div>
        </div>
    </div>
</div>
<script type="text/javascript" src="js/svg.min.js"></script>
<script type="text/javascript" src="js/i18next@19.3.4.min.js"></script>
<script type="text/javascript" src="js/i18nextXHRBackend.min.js"></script>
<script type="text/javascript" src="js/techtree.js"></script>
<script type="text/javascript" src="js/civs.js"></script>
<script type="text/javascript">
    let tree;
    let data = {};
    let connections;
    let parentConnections;
    let connectionpoints;
    let focusedNodeId = null;
    let treeTexts = [];

    const unitClasses = {
        0: "Unused",
        1: "Infantry",
        2: "Turtle Ships",
        3: "Base Pierce",
        4: "Base Melee",
        5: "War Elephants",
        6: "Unused",
        7: "Unused",
        8: "Cavalry",
        9: "Unused",
        10: "Unused",
        11: "<abbr title='(except Port)'>All Buildings</abbr>",
        12: "Unused",
        13: "Stone Defense",
        14: "FE Predator Animals",
        15: "Archers",
        16: "Ships & Camels & Saboteurs",
        17: "Rams",
        18: "Trees",
        19: "<abbr title='(except Turtle Ship)'>Unique Units</abbr>",
        20: "Siege Weapons",
        21: "Standard Buildings",
        22: "Walls & Gates",
        23: "FE Gunpowder Units",
        24: "Boars",
        25: "Monks",
        26: "Castle",
        27: "Spearmen",
        28: "Cavalry Archers",
        29: "Eagle Warriors",
        30: "HD Camels",
        31: "Anti-Leitis",
        32: "Condottieros",
        33: "Organ Gun Damage",
        34: "Fishing Ships",
        35: "Mamelukes",
        36: "Heroes and Kings",
    };

    document.getElementById('civselect').selectedIndex = -1;
    
    setAdvancedStatsState();

    initLocalization(function(){
        loadJson(onJsonData);
    });

    function onJsonData(response) {

        data = JSON.parse(response);

        tree = getDefaultTree();
        connections = getConnections();
        parentConnections = new Map(connections.map(([parent, child]) => [child, parent]));
        connectionpoints = getConnectionPoints(tree);

        let hash = window.location.hash.substr(1);
        let capitalisedHash = hash.substring(0, 1).toUpperCase() + hash.substring(1).toLowerCase();
        const civHashIndex = Object.keys(data.civ_names).indexOf(capitalisedHash);
        if (civHashIndex !== -1) {
            document.getElementById('civselect').selectedIndex = civHashIndex;
        }

        const draw = SVG('techtree').id('root').size(tree.width, tree.height)
            .click((e) => {
                if (e.target.id === 'root') {
                    hideHelp();
                }
            });

        document.getElementById('techtree').onclick = (e) => {
            if (e.target.id === 'techtree') {
                hideHelp();
            }
        };

        // Draw Age Row Highlighters
        let row_height = tree.height / 4;
        draw.rect(tree.width, row_height).attr({fill: '#4d3617', opacity:0.3}).click(hideHelp);
        draw.rect(tree.width, row_height).attr({fill: '#4d3617', opacity:0.3}).click(hideHelp).y(row_height * 2);

        // Add Age Icons
        let icon_height = 112, icon_width = 112;
        let vertical_spacing = (row_height - icon_height) / 2 - 10;
        let margin_left = 20;
        let image_urls = ['dark_age_de.png', 'feudal_age_de.png', 'castle_age_de.png', 'imperial_age_de.png'];
        let age_names = [
            i18next.t(data.age_names["Dark Age"]),
            i18next.t(data.age_names["Feudal Age"]),
            i18next.t(data.age_names["Castle Age"]),
            i18next.t(data.age_names["Imperial Age"])
        ];
        for (let i = 0; i < image_urls.length; i++) {
            let age_image_group = draw.group().click(hideHelp);
            let age_image = age_image_group.image('img/Ages/' + image_urls[i], icon_width, icon_height).y(row_height * i + vertical_spacing).x(margin_left);
            age_image_group.text(age_names[i])
                .font({size: 16, weight: 'bold'})
                .attr({fill: '#000000', opacity: 0.8, 'text-anchor': 'middle'})
                .move(icon_width / 2 + margin_left, age_image.attr('y') + icon_height + 5);
        }

        const connectionGroup = draw.group().attr({id: 'connection_lines'});
        for (let connection of connections) {
            let from = connectionpoints.get(connection[0]);
            let to = connectionpoints.get(connection[1]);
            let intermediate_height = from.y + (tree.element_height * 2 / 3);
            connectionGroup.polyline([from.x, from.y, from.x, intermediate_height, to.x, intermediate_height, to.x, to.y])
                .attr({id: `connection_${connection[0]}_${connection[1]}`})
                .addClass('connection')
                .click(hideHelp);
        }

        for (let lane of tree.lanes) {
            for (let r of Object.keys(lane.rows)) {
                let row = lane.rows[r];
                for (let caret of row) {
                    var item = draw.group().attr({id: caret.id}).addClass('node')
                    var rect = item.rect(caret.width, caret.height).attr({
                        fill: caret.type.colour,
                        id: `${caret.id}_bg`
                    }).move(caret.x, caret.y);
                    let dataType = caret.getDataType();
                    let id = caret.data_id.replace('_copy', '');
                    let langData = data.data[dataType][id];
                    let name = caret.name;
                    let languageNameId = "NONE";
                    if (langData) {
                        languageNameId = langData['LanguageNameId'];
                        name = formatName(i18next.t(languageNameId));
                    } else {
                        // TODO: Invesitage this case further.
                    }

                    var text = item.text(name.toString())
                        .font({size: 9, weight: 'bold'})
                        .attr({fill: '#ffffff', opacity:0.95, 'text-anchor': 'middle', id: caret.id + '_text', i18n: languageNameId})
                        .move(caret.x + caret.width / 2, caret.y + caret.height / 1.5);
                    var image_placeholder = item.rect(caret.width * 0.6, caret.height * 0.6)
                        .attr({fill: '#000000', opacity:0.5, id: caret.id + '_imgph'})
                        .move(caret.x + caret.width * 0.2, caret.y);
                    let prefix = 'img/';
                    var image = item.image(prefix + imagePrefix(caret.id) + '.png', caret.width * 0.6, caret.height * 0.6)
                        .attr({id: caret.id + '_img'})
                        .move(caret.x + caret.width * 0.2, caret.y);
                    var cross = item.polygon([1, 0, 3, 2, 5, 0, 6, 1, 4, 3, 6, 5, 5, 6, 3, 4, 1, 6, 0, 5, 2, 3, 0, 1])
                        .attr({fill: '#ff0000', opacity:0.5, id: caret.id + '_x'})
                        .addClass('cross')
                        .size(caret.width * 0.6, caret.height * 0.6)
                        .move(caret.x + caret.width * 0.2, caret.y);
                    var overlaytrigger = item.rect(caret.width, caret.height)
                        .attr({id: caret.id + '_overlay'})
                        .addClass('node__overlay')
                        .move(caret.x, caret.y)
                        .data({'type': caret.type.type, 'caret': caret, 'name': caret.name, 'id': caret.id})
                        .mouseover(function () {
                            highlightPath(caret.id);
                        })
                        .mouseout(resetHighlightPath)
                        .click(function () {
                            displayHelp(caret.id);
                        });

                    treeTexts.push(text);
                }
            }
        }

        const domSelect = document.getElementById('civselect');
        if (domSelect.selectedIndex === -1) {
            domSelect.selectedIndex = 0;
        }

        loadCiv();
        // Make the xref badges
        createXRefBadges();
        // Create Legend
        create_colour_key();

        document.getElementById('loading').style.display = 'none';
    }

    function setAdvancedStatsState() {
        try {
            let showAdvancedStats = localStorage.getItem('showAdvancedStats');
            let advancedStats = document.getElementById('advanced-stats');
            if (showAdvancedStats === 'true') {
                advancedStats.open = true;
            }
            advancedStats.onclick = onAdvancedStatsStateUpdate;
        } catch (e) {
            // pass
        }
    }

    function onAdvancedStatsStateUpdate() {
        try {
            localStorage.setItem('showAdvancedStats', (!document.getElementById('advanced-stats').open).toString());
        } catch (e) {
            // pass
        }
    }

    function imagePrefix(name) {
        return name.replace('_copy', '')
            .replace("building_", "Buildings/")
            .replace("unit_", "Units/")
            .replace("tech_", "Techs/");
    }

    function loadCiv() {
        const domSelect = document.getElementById('civselect');
        const domCivText = document.getElementById('civtext');
        const domCivLogo = document.getElementById('civlogo');

        const dataKey = domSelect.children[domSelect.selectedIndex].getAttribute('data-key'); // i.e: "Aztecs"
        civ(dataKey, tree);
        domCivText.innerHTML = i18next.t(data.civ_helptexts[dataKey]);
        domCivText.setAttribute('data-i18n', data.civ_helptexts[dataKey]);
        domCivLogo.src = `./img/Civs/${dataKey.toLowerCase()}.png`;
        window.location.hash = dataKey;
        hideHelp();
    }

    function loadJson(callback) {

        var xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', 'data/data.json', true);
        xobj.onreadystatechange = function () {
            if (xobj.readyState === 4 && xobj.status === 200) {
                // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }

    function resetHighlightPath() {
        unhighlightPath();
        if (focusedNodeId) {
            highlightPath(focusedNodeId);
        }
    }

    function unhighlightPath() {
        SVG.select('.node.is-highlight, .connection.is-highlight')
            .removeClass('is-highlight');
    }

    function highlightPath(caretId) {
        recurse(caretId);

        function recurse(caretId) {
            SVG.get(caretId).addClass('is-highlight');

            const parentId = parentConnections.get(caretId);
            if (!parentId) return;

            const line = SVG.get(`connection_${parentId}_${caretId}`);
            if (line) {
                // Move to the end of the <g> element so that it is drawn on top.
                // Without this, the line would be highlighted, but other unhighlighted
                // connection lines could be drawn on top, undoing the highlighting.
                line.front().addClass('is-highlight');
            }
            recurse(parentId);
        }
    }

    function displayHelp(caretId) {
        focusedNodeId = caretId;
        let helptextContent = document.getElementById("helptext__content");
        let helptextAdvancedStats = document.getElementById("helptext__advanced_stats");
        let overlay = SVG.get(`${caretId}_overlay`);
        let name = overlay.data('name');
        let id = overlay.data('id').replace('_copy', '');
        let caret = overlay.data('caret');
        let type = overlay.data('type');
        helptextContent.innerHTML = getHelpText(name, id, type);
        helptextAdvancedStats.innerHTML = getAdvancedStats(name, id, type);
        styleXRefBadges(name, id, type);
        positionHelptext(caret);
        resetHighlightPath();
    }

    function hideHelp() {
        focusedNodeId = null;
        const helptext = document.getElementById("helptext");
        helptext.style.display = "none";
        resetHighlightPath();
    }

    function positionHelptext(caret) {
        const helptext = document.getElementById("helptext");
        helptext.style.display = "block";
        positionHelptextBelow(caret, helptext)
        || positionHelptextAbove(caret, helptext)
        || positionHelptextToLeftOrRight(caret, helptext);
    }

    function positionHelptextBelow(caret, helptext) {
        let top = caret.y + caret.height + document.getElementById('root').getBoundingClientRect().top;
        let helpbox = helptext.getBoundingClientRect();
        if (top + helpbox.height > tree.height) {
            return false;
        }

        let destX = caret.x - helpbox.width;
        let techtree = document.getElementById('techtree');
        if (destX < 0 || destX - techtree.scrollLeft < 0) {
            destX = techtree.scrollLeft;
        }
        helptext.style.top = top + "px";
        helptext.style.left = destX + 'px';
        return true;
    }

    function positionHelptextAbove(caret, helptext) {
        let helpbox = helptext.getBoundingClientRect();
        let top = caret.y - helpbox.height + document.getElementById('root').getBoundingClientRect().top;
        if (top < 0) {
            return false;
        }

        let destX = caret.x - helpbox.width;
        let techtree = document.getElementById('techtree');
        if (destX < 0 || destX - techtree.scrollLeft < 0) {
            destX = techtree.scrollLeft;
        }
        helptext.style.top = top + "px";
        helptext.style.left = destX + 'px';
        return true;
    }

    function positionHelptextToLeftOrRight(caret, helptext) {
        let helpbox = helptext.getBoundingClientRect();
        let top = 0;
        let destX = caret.x - helpbox.width;
        let techtree = document.getElementById('techtree');
        if (destX < 0 || destX - techtree.scrollLeft < 0) {
            destX = caret.x + caret.width;
        }
        helptext.style.top = top + "px";
        helptext.style.left = destX + 'px';
    }

    function getHelpText(name, id, type) {
        let entitytype = getEntityType(type);
        const items = id.split('_', 1);
        id = id.substring(items[0].length + 1);
        let text = i18next.t(data.data[entitytype][id]['LanguageHelpId']);
        if (text === undefined) {
            return "?";
        }
        text = text.replace(/\s<br>/g, '');
        text = text.replace(/\n/g, '');
        if (type === "TECHNOLOGY") {
            text = text.replace(/(.+?\(‹cost›\))(.*)/m,
                '<p class="helptext__heading">$1</p>' +
                '<p class="helptext__desc">$2</p>');
        } else {
            text = text.replace(/(.+?\(‹cost›\))(.+?)<i>\s*(Upgrades:.+?)<\/i>(.*)/m,
                '<p>$1</p>' +
                '<p>$2</p>' +
                '<p><em>$3</em></p>' +
                '<p class="helptext__stats">$4</p>');
        }
        let meta = data.data[entitytype][id];
        if (meta !== undefined) {
            text = text.replace(/‹cost›/, i18next.t('Cost', { value: cost(meta.Cost) }));
            let stats = []
            if (text.match(/‹hp›/)) {
                stats.push(i18next.t('HP', { value: meta.HP }));
            }
            if (text.match(/‹attack›/)) {
                stats.push(i18next.t('Attack', { value: meta.Attack }));
            }
            if (text.match(/‹(A|a)rmor›/)) {
                stats.push(i18next.t('Armor', { value: meta.MeleeArmor }));
            }
            if (text.match(/‹(P|p)iercearmor›/)) {
                stats.push(i18next.t('Piercearmor', { value: meta.PierceArmor }));
            }
            if (text.match(/‹garrison›/)) {
                stats.push(i18next.t('Garrison', { value: meta.GarrisonCapacity }));
            }
            if (text.match(/‹range›/)) {
                stats.push(i18next.t('Range', { value: meta.Range }));
            }
            stats.push(minRangeIfDefined(meta.MinRange, "Min Range"));
            stats.push(ifDefined(meta.LineOfSight, "Line of Sight"));
            stats.push(ifDefined(meta.Speed, "Speed"));
            stats.push(secondsIfDefined(meta.TrainTime, "Build Time"));
            stats.push(secondsIfDefined(meta.ResearchTime, "Research Time"));
            stats.push(ifDefined(meta.FrameDelay, "Frame Delay"));
            stats.push(secondsIfDefined(meta.ReloadTime, "Reload Time"));
            stats.push(accuracyIfDefined(meta.AccuracyPercent, "Accuracy"));
            const statsFormatted = "<h3>" + i18next.t("Stats") + "</h3><p>" + stats.filter(Boolean).join(', ') + "<p>";
            text = text.replace(/<p class="helptext__stats">(.+?)<\/p>/, statsFormatted);
        } else {
            console.error("No metadata found for " + name);
        }
        return text;
    }

    function getAdvancedStats(name, id, type) {
        let entitytype = getEntityType(type);
        const items = id.split('_', 1);
        id = id.substring(items[0].length + 1);
        let meta = data.data[entitytype][id];
        let text = ''
        if (meta !== undefined) {
            text += arrayIfDefinedAndNonEmpty(meta.Attacks, '<h3>Attacks</h3>');
            text += arrayIfDefinedAndNonEmpty(meta.Armours, '<h3>Armours</h3>');
        } else {
            console.error("No metadata found for " + name);
        }
        return text;
    }

    function getEntityType(type) {
        let entitytype = 'buildings';
        if (type === "UNIT" || type === "UNIQUEUNIT") {
            entitytype = 'units';
        }
        if (type === "TECHNOLOGY") {
            entitytype = 'techs';
        }
        return entitytype;
    }

    /**
     * Create the Cross-Reference badges. This is done at load time in order to avoid re-making the
     * badges at runtime per-click on a new unit.
     * 
     * @return A container with buttons + images for each civ to be used in cross referencing.
     */
     function createXRefBadges() {
        let xRef = document.getElementById('helptext__x_ref');
        let xRefLinks = document.createElement('div');
        xRefLinks.id = "helptext__x_ref__container";
        for (let civ of Object.keys(data.civ_names)) {
            let xRefLink = document.createElement('button');
            xRefLink.addEventListener('click', function() {
                const domSelect = document.getElementById('civselect');
                var index;
                for (var i=0; i<domSelect.children.length; ++i) {
                    if (domSelect.children[i].getAttribute('data-key')===civ) {
                        index = i;
                        break;
                    }
                }
                domSelect.selectedIndex = index;
                loadCiv();
            });

            let xRefImage = document.createElement('img');

            xRefImage.src = `./img/Civs/${civ.toLowerCase()}.png`;
            xRefImage.title = i18next.t(data.civ_names[civ]);
            xRefImage.setAttribute('data-i18n', data.civ_names[civ]);
            xRefImage.id = `xRef__badge__${civ}`;
            xRefImage.classList.add('xRef__badge');
            xRefLink.appendChild(xRefImage);
            xRefLinks.appendChild(xRefLink);
        }
        xRef.appendChild(xRefLinks)
    }

    /** 
     * Set on/off of all cross reference badges for a single unit.
     * 
     * @param {string} name The name of the entity being cross-referenced. 
     * @param {string} id The id of the entity being cross-referenced.
     * @param {string} type The type of the entity being cross-referenced.
     */
    function styleXRefBadges(name, id, type) {
        let horseDisabledAll = horseDisabledBuildings.map((id)=>`building_${id}`)
            .concat(horseDisabledUnits.map((id)=>`unit_${id}`))
            .concat(horseDisabledTechs.map((id)=>`tech_${id}`));
        for (let civ of Object.keys(data.civ_names)) {
            let xRefImage = document.getElementById(`xRef__badge__${civ}`);
            // By default, assume that this unit can be built.
            let found = true;
            // Get the config objects
            let enabled = civsConfig[`${civ}`]['enabled'];
            let disabled = civsConfig[`${civ}`]['disabled'];
            let unique = civsConfig[`${civ}`]['unique'];

            // Make sure this civ exists
            if (civsConfig[`${civ}`]) {
                // Fast-Fail horses if civ disablesHorses
                if (civsConfig[`${civ}`]['disableHorses'] &&
                    horseDisabledAll.includes(id)) {
                    found = false;
                }
                if (type === "UNIT") {
                    // There are 2 ways for a UNIT to be disabled.
                    //      1. The unit is disabled by default, and not 
                    //         specifically enabled in the config.
                    //      2. The unit is disabled in the specific config.
                    if (defaultDisabledUnits.map((id)=>`unit_${id}`).includes(id) &&
                        (!enabled ||
                         !enabled['units'] ||
                         !enabled['units'].map((id)=>`unit_${id}`).includes(id))) {
                        found = false;
                    } else if (disabled &&
                            disabled['units'] &&
                            disabled['units'].map((id)=>`unit_${id}`).includes(id)) {
                        found = false;
                    }
                } else if (type === "UNIQUEUNIT") {
                    // There are 2 ways for a UNIQUEUNIT to be disabled.
                    //      1. The UNIQUEUNIT can be enabled in 'unique'.
                    //      2. The UNIQUEUNIT can be enabled in 'unit'.
                    //          e.g. genitour
                    if ((!unique ||
                         !('unit_'+unique[0] === id || 'unit_'+unique[1] === id)) &&
                        (!enabled || !enabled['units'] ||
                         !enabled['units'].map((id)=>`unit_${id}`).includes(id))) {
                        found = false;    
                    }
                } else if (type === "TECHNOLOGY") {
                    // Unique Technologies are disabled by default
                    // Regular Technologies are only ever disabled. See js/techtree.js#resetToDefault
                    // if there is a tech object in disabled, and this tech is in it
                    if (getDefaultDisabledTechs().map((id) => `tech_${id}`).includes(id) &&
                        (!unique ||
                         !unique.slice(2,4).map((id) => `tech_${id}`).includes(id))) {
                        found = false;
                    } else if (disabled['techs'] && disabled['techs'].map((id) => `tech_${id}`).includes(id)) {
                        found = false;
                    }
                }
                else if (type === "BUILDING") {
                    // There are 2 ways for a BUILDING to be disabled.
                    //      1. The building is disabled by default, and not 
                    //         specifically enabled in the config.
                    //      2. The building is disabled in the specific config.
                    if (defaultDisabledBuildings.includes(id) &&
                    (!enabled ||
                    !enabled['buildings'] ||
                    !enabled['buildings'].map((id)=>`building_${id}`).includes(id))) {
                        found = false;
                    } else if (disabled &&
                               disabled['buildings'] &&
                               disabled['buildings'].map((id)=>`building_${id}`).includes(id)) {
                        found = false;
                    }
                }
            }
            if (found) {
                xRefImage.style.opacity = '100%';
            } else {
                xRefImage.style.opacity = '20%';
            }
        }
    }

    function getDefaultDisabledTechs() {
        return Object.keys(civsConfig).map((key) => civsConfig[key].unique.slice(2, 4)).flat();
    }

    function ifDefined(value, locKey) {
        if (value !== undefined) {
            return " " + i18next.t(locKey, { value: value });
        } else {
            return "";
        }
    }

    function secondsIfDefined(value, locKey) {
        if (value !== undefined) {
            return " " + i18next.t(locKey, { value: value }) + "s";
        } else {
            return "";
        }
    }

    function accuracyIfDefined(value, locKey) {
        if (value !== undefined && value < 100) {
            return " " + i18next.t(locKey, { value: value }) + "%";
        } else {
            return "";
        }
    }

    function minRangeIfDefined(value, locKey) {
        if (value !== undefined && value > 0) {
            return " " + i18next.t(locKey, { value: value });
        } else {
            return "";
        }
    }

    // TODO: Localize
    function arrayIfDefinedAndNonEmpty(attacks, prefix) {
        if (attacks === undefined || attacks.length < 1) {
            return "";
        } else {
            const strings = [];
            for (let attack of attacks) {
                const amount = attack['Amount'];
                const clazz = unitClasses[attack['Class']];
                strings.push(`${amount} (${clazz})`);
            }
            return prefix + '<p>' + strings.join(', ') + "</p>";
        }
    }

    // Do not localize
    function cost(cost_object) {
        let value = "";
        if ("Food" in cost_object) {
            value += " " + cost_object.Food + "F";
        }
        if ("Wood" in cost_object) {
            value += " " + cost_object.Wood + "W";
        }
        if ("Gold" in cost_object) {
            value += " " + cost_object.Gold + "G";
        }
        if ("Stone" in cost_object) {
            value += " " + cost_object.Stone + "S";
        }
        return value;
    }

    function create_colour_key() {
        let legend = [TYPES.UNIQUEUNIT, TYPES.UNIT, TYPES.BUILDING, TYPES.TECHNOLOGY];
        let kc = document.getElementById('color_key');
        let tr = null
        for (let index in legend) {
            if (index % 2 === 0) {
                tr = document.createElement('tr');
            }
            let td_color = document.createElement('td');
            td_color.style.backgroundColor = legend[index]['colour'];
            td_color.style.border = '1px outset #8a5d21';
            tr.appendChild(td_color);
            let td_type = document.createElement('td');
            td_type.innerText = i18next.t(data.tech_tree_strings[legend[index]['name']]);
            tr.appendChild(td_type);
            if (index % 2 === 1) {
                kc.appendChild(tr);
            }
        }
        document.getElementById('key__label').innerText = i18next.t(data.tech_tree_strings["Key"]);
    }

    /**
     * Initializes localization engine, and localizes the website
     * to the last-specified language (stored in localStorage, if available).
     *
     * @param {function} [callback] - Invoked when the initialization subsystem is done initializing.
     */
    function initLocalization(callback) {

        // get language from localStorage, or default to English.
        const initLocale = localStorage.getItem('user-locale') || 'en';

        // Add click events to localization buttons.
        var langButtons = document.querySelectorAll('[data-lang]');
        for (var i=0; i<langButtons.length; ++i) {
            langButtons[i].addEventListener('click', (event) => {
                event.preventDefault();
                const langCode = event.target.getAttribute('data-lang');
                localStorage.setItem('user-locale', langCode); // Only store when UI is involved.
                setLanguage(langCode);
            });
        }

        // Both i18next and i18nextXHRBackend are global variables
        // injected by their respective <script> tags.
        i18next
            .use(i18nextXHRBackend)
            .init({
                // https://www.i18next.com/overview/configuration-options
                lng: initLocale,
                fallbackLng: 'en',
                ns: ['common', 'strings'],
                defaultNS: 'common',
                fallbackNS: ['strings'],
                backend: {
                    // Documentation: https://github.com/i18next/i18next-xhr-backend
                    loadPath: 'data/locales/{{lng}}/{{ns}}.json',
                    crossDomain: false,
                    withCredentials: false,
                    overrideMimeType: false
                }
            },
            function onLocalization(err, _t) {
                onLanguageSet(err, _t);
                callback && callback();
            });
    }

    /**
     * Changes the language by loading the appropriate
     * localization json from server.
     */
    function setLanguage(langCode) {

        // Avoid setting the same language again...
        if (langCode === i18next.language) {
            return
        }

        //document.getElementById('civtext').innerText = '';
        document.getElementById('loading').style.display = 'block';
        i18next.changeLanguage(langCode, onLanguageSet);
    }

    /**
     * Invoked every time the languate is set.
     * Responsible for updating the site's locales (strings).
     *
     * @param {Array[]} err - populated if there's an error settings the language, else null
     * @param {function} _t - A reference to function: i18next.t
     */
    function onLanguageSet(err, _t) {

        document.getElementById('loading').style.display = 'none';

        console.log('Language:', i18next.language);

        // Update HTML text nodes
        var elements = document.querySelectorAll('[data-i18n]');
        for (var i=0, len=elements.length; i<len; ++i) {

            var domElem = elements[i];
            var locKey = domElem.getAttribute('data-i18n');

            if (!locKey) {
                console.warn('Could not localize: (' + locKey + ')');
                continue;
            }

            // Set localized string back into the DOM element's end-user visible property
            switch (domElem.nodeName) {

                case 'OPTION':
                case 'SPAN':
                    domElem.innerText = _t(locKey);
                    break;

                case "P":
                    domElem.innerHTML = _t(locKey);
                    break;

                case "IMG":
                    domElem.title = _t(locKey);

            }
        }

        // Update SVG text nodes
        treeTexts.forEach(svgText => {
            let locKey = svgText.node.getAttribute('i18n');
            if (locKey === "NONE") {
                return;
            }
            let strTxt = i18next.t(locKey);
            let txt = formatName(strTxt);
            svgText.text(txt);
        })

        hideHelp();
    }
</script>
</body>
</html>
